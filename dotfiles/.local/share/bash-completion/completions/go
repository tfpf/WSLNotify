# Does not take any arguments.
_go_bug_completer()
{
    COMPREPLY=()
}

# Takes multiple arguments: options and package names. If an option requires a
# value, try to complete the value if possible (otherwise, do not complete it).
# If it does not require a value, complete with options if the current word
# starts with a hyphen, else fall back to normal completion.
_go_build_completer()
{
    local options="-a -asan -asmflags -buildmode -buildvcs -compiler -gccgoflags -gcflags -installsuffix -ldflags -linkshared -mod -modcacherw -modfile -msan -n -overlay -p -pkgdir -race -tags -toolexec -trimpath -v -work -x"
    case $_GO_COMPLETER_PREVIOUS in
        (-buildmode) COMPREPLY=($(compgen -W "archive c-archive c-shared default exe pie plugin shared" -- $_GO_COMPLETER_CURRENT));;
        (-compiler) COMPREPLY=($(compgen -W "gc gccgo" -- $_GO_COMPLETER_CURRENT));;
        (-mod) COMPREPLY=($(compgen -W "mod readonly vendor" -- $_GO_COMPLETER_CURRENT));;
        (-overlay) compopt -o default;;
        (-pkgdir) compopt -o dirnames;;
        (-asmflags | -gccgoflags | -gcflags | -installsuffix | -ldflags | -modfile | -p | -tags | -toolexec) COMPREPLY=();;
        (*) case $_GO_COMPLETER_CURRENT in
                (-*) COMPREPLY=($(compgen -W "$options" -- $_GO_COMPLETER_CURRENT));;
                (*) compopt -o default;;
            esac;;
    esac
}

# Takes the same arguments as `go build`, and some other options. I'll ignore
# the `go build` options for now, since I don't see a use case for cleaning
# specific builds.
_go_clean_completer()
{
    local options="-cache -fuzzcache -i -modcache -n -r -testcache -x"
    case $_GO_COMPLETER_CURRENT in
        (-*) COMPREPLY=($(compgen -W "$options" -- $_GO_COMPLETER_CURRENT));;
        (*) compopt -o default;;
    esac
}

# Just like `go clean`.
_go_doc_completer()
{
    local options="-all -c -cmd -short -src -u"
    case $_GO_COMPLETER_CURRENT in
        (-*) COMPREPLY=($(compgen -W "$options" -- $_GO_COMPLETER_CURRENT));;
        (*) compopt -o default;;
    esac
}

# Takes multiple arguments: options.
_go_env_completer()
{
    local options="-json -u -w"
    local variables=$(go env | awk -F = '{print $1}')
    local complete_with_variables=0
    if [ $_GO_COMPLETER_PREVIOUS = -u -o $_GO_COMPLETER_PREVIOUS = -w ]
    then
        # `-u` and `-w` must be completed with Go environment variables.
        complete_with_variables=1
    elif [[ $_GO_COMPLETER_CURRENT != -* ]]
    then
        # `-u` and `-w` can accept multiple arguments. Scan backwards to find
        # the most recent option argument to see if it was one of them.
        for ((i = ${#COMP_WORDS[@]} - 2; i >= 2; --i))
        do
            case ${COMP_WORDS[i]} in
                (-u | -w) complete_with_variables=1; break;;
                (-*) break;;
            esac
        done
    fi
    if [ $complete_with_variables -eq 1 ]
    then
        COMPREPLY=($(compgen -W "$variables" -- $_GO_COMPLETER_CURRENT))
    else
        COMPREPLY=($(compgen -W "$options" -- $_GO_COMPLETER_CURRENT))
    fi
}

# Takes only one more argument, which should one of the Go subcommands other
# than `help`, or one of the Go help topics.
_go_help_completer()
{
    if [ $COMP_CWORD -eq 2 ]
    then
        local subcommands="bug build clean doc env fix fmt generate get install list mod work run test tool version vet"
        local topics="buildconstraint buildmode c cache environment filetype go.mod gopath gopath-get goproxy importpath modules module-get module-auth packages private testflag testfunc vcs"
        local wordlist=$subcommands+$topics
        COMPREPLY=($(compgen -W "$wordlist" -- $_GO_COMPLETER_CURRENT))
    else
        COMPREPLY=()
    fi
}

_go_completer()
{
    _GO_COMPLETER_CURRENT=$2
    _GO_COMPLETER_PREVIOUS=$3
    local cmd=${COMP_WORDS[1]}
    echo "'$_GO_COMPLETER_PREVIOUS' '$_GO_COMPLETER_CURRENT' '${COMP_WORDS[1]}'" >> f

    if [ $COMP_CWORD -eq 1 ]
    then
        local subcommands="bug build clean doc env fix fmt generate get help install list mod work run test tool version vet"
        COMPREPLY=($(compgen -W "$subcommands" -- $_GO_COMPLETER_CURRENT))
        unset _GO_COMPLETER_CURRENT _GO_COMPLETER_PREVIOUS
        return
    fi

    case $cmd in
        (bug) _go_bug_completer;;
        (build) _go_build_completer;;
        (help) _go_help_completer;;
        (clean) _go_clean_completer;;
        (doc) _go_doc_completer;;
        (env) _go_env_completer;;
        (*) COMPREPLY=();;
    esac
    unset _GO_COMPLETER_CURRENT _GO_COMPLETER_PREVIOUS
}

complete -F _go_completer go
